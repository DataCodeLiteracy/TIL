# 스코프

## 스코프란?

스코프(scope)는 프로그래밍에서 변수의 유효 범위를 나타내는 개념입니다. 변수가 선언되고 사용되는 범위를 의미하며, 해당 범위 내에서만 변수에 접근하고 조작할 수 있습니다. 스코프는 변수의 가시성과 생존 기간을 제어하는 역할을 합니다.

주요한 스코프 유형은 다음과 같습니다:

1. 전역 스코프(Global Scope): 전역 스코프는 프로그램의 최상위에서 선언된 변수들이며, 어디서든 접근 가능합니다. 전역 스코프에서 선언된 변수는 프로그램이 종료될 때까지 유지됩니다.
2. 지역 스코프(Local Scope): 함수 내부에서 선언된 변수는 해당 함수의 지역 스코프에 속하며, 함수 외부에서는 접근할 수 없습니다. 함수 내부에서 선언한 변수는 함수 실행이 끝나면 소멸됩니다.
3. 블록 스코프(Block Scope): 블록 스코프는 중괄호 {} 로 둘러싸인 범위 내에서 변수가 선언되고 유효한 범위를 말합니다. ES6에서 let과 const 키워드를 사용하면 블록 스코프를 가지는 변수를 생성할 수 있습니다.

스코프의 중요한 개념 중 하나는 스코프 체인(scope chain)입니다. 스코프 체인은 변수를 찾을 때 현재 스코프에서 시작하여 부모 스코프로 거슬러 올라가며 변수를 찾는 과정을 의미합니다. 이를 통해 중첩된 함수에서 외부 스코프의 변수에 접근할 수 있습니다.

스코프는 변수의 이름 충돌을 방지하고 변수를 관리하며, 코드의 구조와 유지보수에 영향을 미치는 중요한 개념입니다.

```jsx
// 코드 블럭: { }, if() { }, for() { }, function() { }
// 블럭 외부에서는 블럭 내부의 변수를 참조할 수 ❌
{
  const a = 'a';
}
console.log(a);
const b = 'b';

// 함수 외부에서는 함수 내부의 변수를 참조 ❌
function print() {
  const message = 'Hello World';
  console.log(message);
}
console.log(message);

// 함수 외부에서는 함수의 매개변수를 참조 ❌
function sum(a, b) {
  console.log(a, b);
}
console.log(a, b);
```

```jsx
{
  const x = 1;
  {
    const y = 2;
    console.log(x);
  }
  console.log(x);
  // console.log(y);
}

const text = 'global'; // 전역 변수, 전역 스코프 (글로벌 변수, 글로벌 스코프)
{
  const text = 'inside block1'; // 지역 변수(로컬변수), 지역 스코프(로컬스코프)
  {
    const text = 'inside block2';
    console.log(text);
  }
}
```

## 가비지 컬렉터

가비지 컬렉터(Garbage Collector)는 프로그래머가 직접 메모리 관리를 하지 않아도 되도록 자동으로 더 이상 사용하지 않는 메모리를 식별하고 회수하는 기능을 수행하는 프로그램 또는 기술입니다. 이는 프로그래머가 메모리 할당과 해제를 수동으로 처리하지 않아도 되므로 메모리 누수와 관련된 문제를 완화하고 프로그래밍 생산성을 높이는 데 도움이 됩니다.

자바스크립트의 가비지 컬렉터는 다른 언어의 가비지 컬렉터와 다소 다른 특징을 가지고 있습니다:

1. **참조 계수 기반 가비지 컬렉션을 사용하지 않음**: 일부 언어에서는 객체가 몇 개의 참조를 가지고 있는지 세는 참조 계수(reference counting) 방식의 가비지 컬렉션을 사용합니다. 하지만 자바스크립트는 참조 계수 방식을 사용하지 않습니다.
2. **Mark-and-Sweep 알고리즘**: 대신 자바스크립트는 주로 Mark-and-Sweep 알고리즘을 기반으로 가비지 컬렉션을 수행합니다. 이 알고리즘은 도달 가능한 객체들을 표시(mark)하고, 표시되지 않은 객체들을 삭제(sweep)하여 사용되지 않는 메모리를 회수합니다.
3. **루트 객체를 기준으로 스캔**: 자바스크립트 가비지 컬렉터는 루트(root) 객체를 기준으로 시작하여 도달 가능한 모든 객체를 순회하며 사용 중인 객체를 식별합니다. 이로 인해 간접적인 순환 참조(circular reference)도 처리할 수 있습니다.
4. **메모리 해제 시점**: 자바스크립트의 가비지 컬렉터는 객체가 더 이상 도달 가능하지 않을 때, 해당 객체의 메모리를 해제합니다. 이 과정은 일반적으로 브라우저나 런타임 환경이 자체적으로 판단하며 개발자가 직접 제어할 수는 없습니다.
5. **참조 사이클과 WeakMap**: 가끔 객체 간에 순환 참조가 발생하여 메모리 누수가 발생할 수 있습니다. 이러한 경우에 자바스크립트는 WeakMap과 같은 도구를 사용하여 참조 사이클을 극복하고 메모리 관리를 보다 효율적으로 수행할 수 있도록 돕습니다.

자바스크립트의 가비지 컬렉터는 언어의 특성과 런타임 환경에 맞게 설계되어 있으며, 개발자가 명시적으로 메모리 관리를 수행하지 않더라도 효율적인 메모리 사용을 지원하는 역할을 합니다.

```jsx
// 글로벌 변수는 앱이 종료될때까지 계속 메모리에 유지됨!
const global = 1;
{
  // 블럭 내부에서만 존재하고, 블럭이 끝나면 자동으로 소멸됨 (GC)
  const local = 1;
}

function print() {
  // 함수 내부에서도 블럭안에서 필요한 경우에는
  // 필요한 곳에서! 블럭 안에서 변수를 선언하고 사용해야 함
  if (true) {
    let temp = 0;
  }
}
```

## 렉시컬 환경

렉시컬 환경(Lexical Environment)은 자바스크립트의 실행 컨텍스트를 구성하는 중요한 개념 중 하나입니다. 실행 컨텍스트는 코드가 실행되는 환경을 나타내며, 렉시컬 환경은 그 중에서 식별자와 그에 연결된 값, 스코프 체인(Scope Chain) 등의 정보를 관리하는 컴포넌트입니다.

렉시컬 환경은 크게 두 가지 요소로 구성됩니다:

1. **환경 레코드(Environment Record)**: 환경 레코드는 현재 컨텍스트 내에서 선언된 모든 변수와 함수를 저장하고 있는 객체입니다. 렉시컬 환경 내에서 변수의 값과 식별자, 함수 등이 실제로 저장되는 공간입니다. 환경 레코드는 변수 객체(variable object)와 유사한 역할을 하며, 환경 내에서 선언된 모든 식별자에 대한 정보를 보유하고 있습니다.
2. **외부 렉시컬 환경 참조(Outer Lexical Environment Reference)**: 현재 렉시컬 환경이 내포된 스코프 체인을 구성하기 위해 사용됩니다. 스코프 체인은 해당 렉시컬 환경의 상위 스코프 또는 외부 렉시컬 환경을 참조하는 연결 구조입니다. 이를 통해 변수와 함수 등이 중첩된 스코프 내에서 상위 스코프의 변수에 접근할 수 있습니다.

렉시컬 환경은 자바스크립트 엔진이 변수와 함수의 식별자를 해석하고 접근할 수 있도록 도와주는 중요한 요소입니다. 실행 컨텍스트를 구성하고, 스코프 체인을 형성하며, 변수와 함수에 접근하고 조작하는 데 필요한 정보를 제공합니다.

- 각각의 블럭 스코프는 렉시컬 환경이라는 내부 오브젝트를 가지고 있다.

## 호이스팅

```jsx
// 함수의 호이스팅은 함수의 선언문 전에 호출이 가능하게 해줌
// 함수의 선언문은 선언 이전에도 호출이 가능함
print();

function print() {
  console.log('Hello');
}

// 변수(let, const)와 클래스는 선언만 호이스팅이 되고,
// 초기화는 안됨
// 초기화 전, 변수에 접근하면 컴파일(빌드) 에러가 발생
// console.log(hi);
let hi = 'hi';
let func1 = function () {};

// const cat = new Cat();
class Cat {}

let x = 1;
{
  console.log(x);
  let x = 2;
}
```

## 엄격모드

```jsx
"use strict";
// 엄격 모드 strict mode
// 리액트와 같은 프레임워트 사용시 기본적으로 엄격 모드임
// var x = 1;
// delete x;

function add(x) {
  var a = 2;
  var b = a + x;
  console.log(this);
}
add(1);

const array = [1, 2, 3];
for (const num of array) {
  console.log(num);
}
```