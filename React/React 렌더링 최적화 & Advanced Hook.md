# React 렌더링 최적화 & Advanced Hook

---

해당 글은 원티드 인턴쉽 강좌를 복습하면서 정리한 글입니다.

---

### 명령형 프로그래밍 vs 선언형 프로그래밍

React 공식문서를 보면 가장 첫번째 장점으로 **“선언형”**을 내세우고 있다.

선언형은 정확히 무엇이고 명령형은 무엇인가?

```tsx
명령형 프로그래밍은 무엇을 **어떻게** 할 것인가에 가깝고, 선언형 프로그래밍은 **무엇을** 할 것인가와 가깝다.
```

더 모르겠다.

React는 선언형으로 실제 렌더링 과정은 React에서 대신 처리해주고, 개발자는 UI를 설계하는대만 집중하게 해줍니다. 

그럼 명령형은 렌더링 과정도 직접 처리해야 하는 건가?

바닐라 자바스크립트로만 개발할 경우, UI 업데이트를 수동으로 처리해야 한다. DOM API를 사용하여 요소를 선택하고, 속성을 변경하고, 이벤트를 처리하는 등의 작업을 직접 수행해야 한다. 이는 명령형 프로그래밍 방식에 해당하며, 상태 변경에 따른 UI 업데이트를 관리하기 위해 많은 로직과 코드를 작성해야 한다.

리액트는 가상 DOM을 활용하여 선언형 방식으로 UI를 표현하고, 렌더링 업데이트를 효율적으로 처리해준다. 이를 통해 개발자는 UI의 상태 변화를 선언적으로 다룰 수 있다.

하지만 때로는 React 내부에서 처리해주는 렌더링을 최적화 해야 되는 상황이 발생한다. 이러한 상황에서는 React 내부에서 렌더링이 언제 발생하는지, 어떤 과정을 거쳐서 이루어지는지를 이해하고 있어야 각 과정에서 렌더링을 최적화 할 수 있게 된다.

### 리액트에서 리렌더링이 되는 시점

리액트에서 state를 사용하는 이유는 UI와 상태(state)를 연동시키기 위해서이다. 

리액트에서 리렌더링이 발생하는 시점은 state가 변했을 때다. 특정 컴포넌트의 state가 변한다면, 해당 컴포넌트와 해당 컴포넌트의 하위에 있는 모든 컴포넌트들은 리렌더링이 발생하게 된다.

```tsx
“state가 변하면 해당 컴포넌트를 포함한 하위 컴포넌트들은 모두 리렌더링 된다.”라는 명확한 멘탈 모델을 이해
하고 있는 것이 리액트를 이용해서 애플리케이션을 설계하고, 최적화하는데 가장 기본이 되는 사항입니다.
- 원티드 멘토 - 
```

### 리액트의 렌더링 과정

1. 기존 컴포넌트의 UI를 재사용할 지 확인한다.
2. 컴포넌트 함수를 호출한다.
3. 2의 결과를 통해서 새로운 VirtualDOM을 생성한다.
4. 이전의 VirtualDOM과 새로운 VirtualDOM을 비교해서 실제 변경된 부분만 DOM에 적용한다.

리액트는 CRP 과정을 좀 더 효율적으로 처리하기 위해 batching을 이용해서 변경된 부분을 모아서 처리할 수 있다.

이때 리액트를 사용하는 개발자가 할 수 있는 최적화는 렌더링 과정에서의 1, 3번이다.

1.의 경우에는 만약 리렌더링 될 컴포넌트의 UI가 이전의 UI와 동일하다고 판단되는 경우 새롭게 컴포넌트 함수를 호출하지 않고 이전의 결과값을 그대로 사용하도록 함으로서 최적화를 수행할 수 있다.

3.의 경우는 컴포넌트 함수가 호출되면서 만들어질 VirtualDOM의 형태를 비교적 차이가 적은 형태로 만들어지도록 하는 것이다. 예를 들어 UI를 바꾸기 위해서 <div> tag를 <span> 태그로 변환시키는 것 보다는 <div className="block" /> 을 <div className="inline"> 으로 변환시키는 것이 VirtualDOM끼리 비교했을 때 차이가 적은 형태로 만들어지도록 하는 것이다.

### React.memo

앞서 말했듯이 리액트는 state가 변할 경우 해당 컴포넌트와 하위의 컴포넌트들을 모두 리렌더링 한다.
UI가 실질적으로 변화되었는지 안되었는지를 매번 리액트가 렌더링 과정에서 일일이 모든 컴포넌트 트리를 순회하면서 검사하는 것은 비효율적이다. 따라서 리액트에서는 개발자에게 이 컴포넌트가 리렌더링이 되어야 할지 아닐지에 대한 여부를 표현할 수 있는 React.memo 함수를 제공하고 이를 통해 기존의 컴포넌트의 UI를 재사용할 지 판단하는 방법을 채택했다.

```jsx
const MyComponent = React.memo(function MyComponent(props) {
  /* render using props */
});
```

React.memo는 HOC(Higher Order Component)

HOC란 컴포넌트를 인자로 받아서, 컴포넌트를 리턴하는 컴포넌트다.

```jsx
function HOC(Component) {
  /* do something */
	return <Component />
}
```

React.memo로 감싸진 컴포넌트의 경우에는 상위 컴포넌트가 리렌더링 될 경우 무조건 리렌더링 되는 것이 아니라 컴포넌트의 이전의 Props와 다음 렌더링 때 사용될 Props를 비교해서 차이가 있을 경우에만 리렌더링을 수행한다. 만약 차이가 없다면 리렌더링을 수행하지 않고 기존의 렌더링 결과를 재사용한다. 이를 통해 컴포넌트에서 불필요하게 리렌더링이 되는 경우를 막을 수 있다.

### Memoization

Memoization은 특정한 값을 저장해뒀다가, 이후에 해당 값이 필요할 때 새롭게 계산해서 사용하는게 아니라 저장해둔 값을 활용하는 테크닉을 의미한다.

함수 컴포넌트는 근본적으로 함수다. 그리고 리액트는 매 렌더링마다 함수 컴포넌트를 다시 호출한다. 함수는 기본적으로 이전 호출과 새로운 호출간에 값을 공유할 수 없다. 만약 특정한 함수 호출 내에서 만들어진 변수를 다음 함수 호출에도 사용하고 싶다면 그 값을 함수 외부의 특정한 공간에 저장해뒀다가 다음 호출 때 명시적으로 다시 꺼내와야 한다.

이것을 직접 구현하는 것은 꽤나 번거로운 일이고, 특히 함수 컴포넌트에서 이를 구현하고 관리하는 것은 많은 노력이 드는 행위다.

다행히 리액트에서는 함수 컴포넌트에서 값을 memoization 할 수 있도록 API를 제공해주고 있다.

### useMemo

useMemo는 리액트에서 값을 memoization 할 수 있도록 해주는 함수다.

```jsx
// useMemo(callbackFunction, deps]

const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

useMemo는 두가지 인자를 받는다. 첫번째 인자는 콜백함수이며 이 함수에서 리턴하는 값이 메모된다. 두번째 인자는 의존성 배열이다. 메모이제이션을 할 때 주의해야 할 점은 만약 새로운 값을 만들어서 사용해야 하는 상황임에도 불구하고 이전의 결과를 그대로 활용해버리면 버그가 발생할 수 있다는 점이다.

위의 예시에서 a, b 라는 두가지 변수를 이용해서 메모이제이션 하기 위한 값을 계산하고 있다. 그런데 만약 a, b 라는 값이 변경되었는데 이전의 값을 그대로 활용해버리면 의도한 결과와 다른 결과가 나오게 될 것이다.

이런 상황을 방지하기 위해서 useMemo에서는 의존성 배열을 인자로 받아, 의존성 배열에 있는 값 중 하나라도 이전 렌더링과 비교했을 때 변경되었다면 메모된 값을 활용하는 것이 아니라 새로운 값을 다시 계산한다.

### useCallback

useCallback은 useMemo를 조금 더 편리하게 사용할 수 있도록 만든 버전이다.

일반적인 값들은 useMemo를 통해서 메모하기 편리하다. 하지만 함수의 경우에는 useMemo를 사용해서 메모하게 되면 콜백함수에서 또 다른 함수를 리턴하는 형태가 되게 된다. 이는 동작상에는 아무런 이상이 없지만 코드 스타일에 따라 문법적으로 다소 보기가 불편해지는 단점이 있다. 따라서 이러한 동작을 간소화한 useCallback이란 함수를 만들어서 제공해주고 있다.

```jsx
const memorizedFunction = useMemo(() => () => console.log("Hello World"), []);

const memorizedFunction = useCallback(() => console.log("Hello World"), []);
```