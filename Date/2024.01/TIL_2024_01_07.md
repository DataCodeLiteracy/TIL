# TIL_2024_01_07

### Today 요약

1. 책 읽기
2. 자바스크립트 이론 공부

---

# 1*. What I Learned?*

## 서버의 기초 책 읽기

### 서버의 운용 관리 방식

서버의 운용관리 방식에는 설정 변경과 장애 대응, 프로그램 업데이트 등이 있고, 이는 모두 원격으로 통제가 가능하다. 그리고 프로그램 업데이트의 경우 사전에 알려야 하며, 미리 테스트 환경에서 업데이트 해보고 문제가 없다면 프로덕션 환경에서 업데이트를 진행한다. 업데이트 프로그램 전송관리는 보통 WSUS로 한다.

그리고 네트워크 장애의 경우 OSI 물리 계층에서 부터 네트워크 명령어를 통해 하나씩 차근차근 문제를 점검해 나가면서 대응한다.

네트워크와 서버는 시각 정보가 맞지 않으면 문제가 생길 수 있는데 이런 시각 정보를 관리하는 것이 NTP 서버이다.

그리고 장애 발생시 가장 먼저 봐야할 것은 서버나 네트워크 기기의 이벤트가 기록된 로그인데, 이런 로그를 관리하는 서버가 syslog 서버다.

마지막으로 SNMP 서버는 네트워크를 경유해 서버를 감시 및 설정하며 장애를 알리는 서버다.

그리고 서버의 데이터가 소실되는 문제는 정말 중요하기 때문에 반드시 주기적으로 백업을 해야한다.

## 웹의 기초 책 읽기

### 웹 시스템 구축과 운용

웹 시스템을 구축하기 위해서는 일단 어떤 서비스를 개발할 것인지 먼저 명확하게 파악해야 한다. 어떤 사용자에게 주로 제공하며, 사용자들이 어떤 시간대에 주로 이용하고 어떤 기기를 통해 사용하는지 파악한다. 서비스가 제공하는 기능은 어떤 것들이 있는지도 정의한다. 이후에 프로그래밍 언어와 OS, 미들웨어를 선택한다. 그리고 네트워크 구성은 어떤 방식으로 진행할지 결정한다. 네트워크에는 외부 네트워크, 내부 네트워크, DMZ가 있다. DMZ는 외부에서 내부로의 악의적인 요청을 차단하는 역할을 한다. 그렇기 때문에 중요한 정보를 가지고 있는 DB서버의 경우 내부 네트워크에 둔다. 그리고 서버의 구성은 어떻게 할지 정한다. 웹 서버를 여러 대 두어야 하는 상황이라면 로드밸런서를 통해 부하를 분산 시킨다. 웹 서버를 구축하는 방식은 온프레미스 방식과 임대 방식 그리고 클라우드 방식이 있다. 또한 서버의 디스크 구성과 보안 등을 고려해서 설계를 적절하게 해야 한다. 그리고 데이터베이스 설계를 한다.

이후 애플리케이션 설계를 구체적으로 진행한다. 그리고 이 설계를 기반으로 프로그래밍을 한다.

어느 정도 구현이 마무리 된 웹 시스템을 단위테스트와 통합테스트를 통해서 배포전에 정상적으로 동작하는지 확인해야 한다.

그리고 운용하면서 백업과 로그의 관리에 신경을 써야한다. 주기적으로 백업을 해줘야 하며 서버와 네트워크 사이에 문제가 생겼을시 로그의 정보가 중요하기 때문에 로그를 적절하게 필터링해서 적절한 크기로 관리해서 가지고 있어야 한다.

또한 웹사이트의 성능을 주기적으로 신경써서 성능 최적화를 해야하고 취약성을 진단해서 대응해야 한다.

## 자바스크립트 이론 강의

### 클래스

배와 사과는 과일이며 음식이다. 클래스란 과일과 음식처럼 추상적인 개념이고 인스턴스는 배와 사과처럼 구체적인 개념이다.

자바스크립트의 클래스는 프로토타입 체이닝을 통한 상속과 관련이 있다. 상위 프로토타입의 상속을 받기 때문에 불필요한 데이터가 프로토타입에 정의되어 있지 않도록 적절하게 프로퍼티와 메서드를 정의해야 한다.

인스턴스 레벨에서 사용할 필요가 없는 메서드는 클래스 레벨에서 정적 메서드로 정의할 수 있다.

ES6 이전에는 생성자 함수와 프로토타입을 이용해서 클래스를 구현해서 사용했다. 하지만 현재는 ES6가 보편화되어 있기 때문에 class 문법을 사용해서 이 모든 기능들을 쉽게 사용할 수 있다.

```jsx
var extendClass = (function () {
  function Bridge() {}
  return function (Parent, Child) {
    Bridge.prototype = Parent.prototype
    Child.prototype = new Bridge()
    Child.prototype.constructor = Child
    // Child.prototype.superClass = Parent
  }
})()

function Person(name, age) {
  this.name = name || '이름없음'
  this.age = age || '나이모름'
}

Person.prototype.getName = function () {
  return this.name
}

Person.prototype.getAge = function () {
  return this.age
}

function Employee(name, age, position) {
  Person.call(this, name, age)
  // this.superClass(name, age)
  this.position = position || '직책모름'
}

extendClass(Person, Employee)

Employee.prototype.getPosition = function () {
  return this.position
}

const jh = new Employee('종현', 37, '신입')

console.dir(jh)
```
