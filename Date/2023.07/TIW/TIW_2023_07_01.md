# TIW_2023_07_01

# Today_I_Wondered

---

# React

### 미해결

- createBrowserRouter와 Outlet?
    
    예전에는 분명 Outlet을 사용해서 children의 라우팅 문제를 해결했었는데, 지금은 Outlet이 없어도 동작한다. 왜 그런거지?
    
    **`react-router-dom`**의 버전이 업데이트되기 전, 후의 차이일까?
    

# TS

### 미해결

- 프로젝트에 타입스크립트 적용시 가장 최상위 컴포넌트 부터 정의하는 것이 맞을까? 아니면 하위 컴포넌트 부터 정의하는 것이 맞을까?
    
    최상위가 맞을텐데, 그건 그냥 순전히 감과 같은 느낌으로 맞다고 생각하는 것과 같으니까 GPT랑 Bard한테 물어봤다. 뭐가 맞을지, 그 이유는 무엇인지?
    
    - GPT
        
        ```jsx
        리액트 프로젝트에 타입스크립트를 적용할 때, 일반적으로는 가장 먼저 최상위 컴포넌트인 
        index.tsx 또는 app.tsx 파일부터 타입을 적용하는 것이 좋습니다.
        
        그 이유는 다음과 같습니다:
        
        1. 최상위 컴포넌트는 애플리케이션의 진입점이며, 하위 컴포넌트들을 렌더링하는 역할을 담당
        	합니다. 따라서 최상위 컴포넌트에서 타입을 정확히 지정하면 애플리케이션 전체에 대한 타입
        	안정성을 확보할 수 있습니다.
        
        2. 최상위 컴포넌트에서 시작하여 하위 컴포넌트로 내려가면서 타입을 적용하면, 타입스크립트의
        	 장점인 타입 추론과 타입 체크 기능을 최대한 활용할 수 있습니다. 
        	 즉, 상위 컴포넌트의 타입 정보를 활용하여 하위 컴포넌트의 타입을 유추하고 검증할 수 
        	 있습니다.
        
        3. 타입을 최상위 컴포넌트부터 적용하면, 컴포넌트 계층 구조의 상위에서 하위로 내려갈 때 
        	 일관성 있는 타입 정보가 전달됩니다. 이는 개발자가 컴포넌트 간의 관계를 이해하고, 데이터
        	 의 흐름과 상호작용을 추론하기 쉽게 만들어 줍니다.
        
        4. 최상위 컴포넌트에 타입을 적용하면, 이후에 새로운 하위 컴포넌트를 추가하거나 기존 
        	 컴포넌트를 수정할 때 타입 오류를 사전에 방지할 수 있습니다. 
        	 즉, 코드의 확장성과 유지보수성을 향상시킬 수 있습니다.
        
        물론, 프로젝트의 규모와 복잡도에 따라 상황은 달라질 수 있습니다. 
        일부 경우에는 특정 컴포넌트부터 타입을 적용하는 것이 더 효율적일 수도 있습니다. 하지만 
        대부분의 경우에는 최상위 컴포넌트부터 타입을 적용하는 것이 권장되는 접근 방식입니다.
        ```
        
        겹치는 내용이 조금 있는 것 같지만 아무튼 타입 추론이나 안정성을 위해서는 최상위부터 타입을 지정하는 것이 좋다고 말하는 듯하다.
        
    - Bard
        
        ```jsx
        리액트 프로젝트를 타입스크립트를 적용할 때, 가장 먼저 최상위 컴포넌트인 index.ts나 
        app.ts부터 타입을 적용하는 것이 좋습니다. 
        
        그 이유는 최상위 컴포넌트는 프로젝트의 다른 컴포넌트와 연결되는 부분이기 때문입니다. 
        최상위 컴포넌트에 타입을 적용하면, 하위 컴포넌트에 타입을 적용할 때 타입 오류를 방지할 수
        있습니다.
        
        예를 들어, 최상위 컴포넌트에서 하위 컴포넌트를 사용한다고 가정합니다. 
        최상위 컴포넌트에 타입이 적용되어 있지 않으면, 하위 컴포넌트의 타입을 추론할 수 없습니다. 
        따라서 하위 컴포넌트에 타입을 적용할 때 타입 오류가 발생할 수 있습니다.
        
        최상위 컴포넌트에 타입을 적용하면, 하위 컴포넌트의 타입을 추론할 수 있습니다. 
        따라서 하위 컴포넌트에 타입을 적용할 때 타입 오류를 방지할 수 있습니다.
        
        또한, 최상위 컴포넌트에 타입을 적용하면, 프로젝트의 전체적인 구조를 파악하는 데 도움이 
        됩니다. 최상위 컴포넌트에 타입이 적용되어 있으면, 프로젝트의 다른 컴포넌트와의 연결 관계를
        파악할 수 있습니다. 따라서 프로젝트의 구조를 이해하고 유지보수하기가 쉬워집니다.
        
        따라서 리액트 프로젝트를 타입스크립트를 적용할 때는, 가장 먼저 최상위 컴포넌트인 
        index.ts나 app.ts부터 타입을 적용하는 것이 좋습니다.
        ```
        
        정리는 GPT가 더 깔끔하게 해주었지만 결국 비슷한 소리를 하는 것 같다. 
        
- tsconfig파일의 컴파일러 옵션에서 jsx플래그의 “react”와 “react-jsx”의 차이는?
    - GPT
        
        ```jsx
        tsconfig.json 파일의 컴파일러 옵션에서 jsx 설정은 JSX 문법 처리 방식을 지정하는 역할
        을 합니다. 두 가지 주요한 옵션인 "react-jsx"와 "react"에 대해 설명드리겠습니다:
        
        "jsx": "react-jsx": 이 옵션은 JSX 문법을 React.createElement를 사용하여 변환
        			하는 방식을 의미합니다. 이 설정은 React 16 이전 버전과의 하위 호환성을 위해 제공
        			되는 옵션입니다. JSX 문법을 사용할 때 .jsx 확장자를 사용하는 것이 일반적입니다.
        
        "jsx": "react": 이 옵션은 JSX 문법을 React의 JSX 변환기인 Babel을 사용하여 변환
        			하는 방식을 의미합니다. React 16 이상 버전부터는 Babel이 내장되어 JSX 문법 변
        			환을 처리하므로 이 옵션을 사용하는 것이 일반적입니다. JSX 문법을 사용할 때 .tsx
        		  확장자를 사용하는 것이 일반적입니다.
        
        일반적으로 React 프로젝트에서는 "jsx": "react" 옵션을 사용하여 JSX 문법을 처리합니다.
        이렇게 설정하면 Babel이 JSX를 변환하고 React.createElement로 변환된 코드를 생성
        합니다.
        
        따라서, React 프로젝트에서는 "jsx": "react" 옵션을 사용하는 것이 일반적이며, 
        React 16 이전 버전과의 하위 호환성을 유지해야 할 경우에만 "jsx": "react-jsx" 옵션
        을 사용할 수 있습니다.
        ```
        
        그러니까 16이상 버전은 react로 16이하 버전의 호환성을 위해서는 react-jsx로 한다?
        
- 타입 추론을 해주는 걸 굳이 타입을 정의할 필요가 있다? 없다?
    
    당연히 case by case 이겠지만, 현재 내 생각은 타입 추론을 해주는 것들은 굳이 타입 정의를 하지 않아도 된다는 생각을 가지고 있다. 
    
- try catch의 error타입 정의에 대해..

# 기타

### 미해결

- typeAndRefac 브랜치에서 변경사항이 발생, main브랜치에 잠깐 체크아웃 해야되서 git stash 실행하고 main브랜치에서 새로운 변경사항 적용해보고 git checkout . 해서 변경사항을 이전상태로 돌리려고 했지만 이전상태로 돌아가지 않았다.
    
    이 경우에 이전상태로 돌아간다? 이 부분에서 git checkout . 을 한 것이 잘못된 걸까? 예전에 작업하다가 working directory에 있는 모든 파일을 되돌리기 위해 git checkout .을 사용해서 해결했었는데,  지금 경우에는 왜 안되는 걸까? main브랜치에서 typeAndRefac 브랜치를 생성하고 PR 날린 다음에 stash 하고 main에서 작업한 내용들을 git check out . 했는데, 왜 안되는걸까? 그리고 하위브랜치에서 작업한 내용이 merge하지도 않았는데 main에 공유되기도 하는건가?