# TIL_2023_10_19

### Today 요약

1. 과제(배달 주문 앱 구현하기)
2. 코테 1문제

---

# **_1. What I did?_**

## 1.1 과제(배달 주문 앱 구현하기)

오늘 과제는 5주차 토요일 과제를 미리 진행했다. 하루에 과연 어디까지 구현할 수 있을까 했는데, GPT와 함께 하면서 하루만에 한 가지 요구사항 빼고는 전부 구현을 완료했다.

아직 못한 한 가지는 프로젝트에서 적절한 곳에 useEffect, useMemo, useCallback을 활용하라는 부분인데..

context를 이용해서 막상 구현하다 보니까 아무데서도 useEffect를 사용하고 있지 않았다. 리액트 생명주기에 대해서 공부를 좀 더 하면서 useEffect, useMemo, useCallback을 어떤 곳에서 사용하면 적절한지를 고민을 좀 해보자.

이번 프로젝트에서 중점적으로 생각한 건, 절대 props drilling으로 상태나 prop을 전달하지 말고, 강의에서 다뤘던 context를 이용해서 구현해보자는 것이었고, context에 대한 부분은 이번 프로젝트를 통해서 제대로 이해한 것 같다.

useReducer도 이용할 수 있었을지는 좀 더 공부를 한 다음에 고민해봐야 할 것 같다. 아직 useReducer에 대해서 잘 모르니까 어디에 선언해서 사용해야 할지도 감이 잡히질 않는다.

그러니까 한 마디로 동작을 하게끔은 만들어놨지만, 적절하게 잘 사용했는지에 대해서는 자신있게 말하지 못하는 상황이다.

그러니까 이번에 리액트 강의 복습하고, 정기팀회의때 어차피 5주차 복습에 대해서 발표해야 하니까, 금 ~ 일요일 동안 리액트 강의 복습 + 프로젝트 리팩토링 + 부족한 부분 보완하기를 진행하면 될 것 같다.

## 1.2 코테 문제 풀기

### 소인수 분해

처음 풀이과정은 아래와 같다.

```jsx
function solution(n) {
  let answer = []

  for (let i = 2; i < 10000; i++) {
    for (let j = 2; j <= n; j++) {
      if (n % i === 0) {
        n /= i
        answer.push(i)
      } else {
        i++
      }
    }
  }

  return [...new Set(answer)]
}
```

소수로 나눠가는 과정이 얼마나 필요할지 모르니까, 요구사항에 나와있는 2 ≤ n ≤ 10000번 이내로 반복하면 될 것 같아서 for문으로 작성하고, 그 다음에 i로 나눠가는 과정은 최대 n번을 넘지 않을 것 같아서 반복적으로 나누면서 계속 0으로 나누어 떨어질때까지 반복할 수 있도록 하고 더 이상 나누어 떨어지지 않으면 i를 하나 증가시켜서 다시 반복적으로 수행하도록 구현했다. 일단 초반에 제공해주는 3개의 테스트 케이스는 통과했다. 그래서 좀 더 나은 코드가 있을 수 있어 GPT한테 물어봤다.

```jsx
function solution(n) {
  const factors = new Set()

  let divisor = 2

  while (n > 1) {
    if (n % divisor === 0) {
      factors.add(divisor)
      n = n / divisor
    } else {
      divisor++
    }
  }

  return [...factors]
}
```

GPT한테 물어본다음 최종 테스트를 진행시켰는데, 일부 테스트를 통과하지 못했다;;

다음부터는 최종코드까지 통과되었다고 확인한 다음에 GPT한테 물어봐야겠다. 너무 오래 붙잡고 있어도 안되지만 너무 생각을 안하고 답만 보고 풀고 이해하는 것도 지양해야 한다.

하지만 어쨌든 확실히 이렇게 GPT한테 물어보든 다른 사람들이 풀어놓은 코드를 보든 여러가지 코드를 봐야 한다. 그래야 편협한 생각에서 벗어날 수 있다.

GPT 코드를 보면 일단 나중에 중복을 제거할테지만 일단 Set 객체를 생성해서 거기에 반복적으로 2부터 시작해서 하나씩 증가시켜서 나누면서 더 이상 나누어지지 않을 때까지 체크하고 n이 1보다 같아지는 순간까지 반복한다.

그리고 마지막에는 set 객체를 배열로 변환해서 리턴한다.

이번에는 다른 사람의 풀이를 보자.

```jsx
function solution(n) {
  return Array.from(
    new Set(
      [...Array(n + 1).keys()]
        .filter((v) => n % v === 0)
        .filter((v) => {
          for (let i = 2; i < v; i++) {
            if (v % i === 0) return false
          }
          return true
        })
    )
  ).splice(1)
}
```

[...Array(n + 1).keys()] 코드로 0부터 n까지의 숫자를 순서대로 배열에 담는다. 그리고 filter를 이용해 배열에 담긴 요소들을 나누어 떨어지는 요소만 필터한다. 그리고 그렇게 필터 배열을 다시 한 번 반복적으로 돌면서 그 중 에서 소수만 골라내서 배열에 다시 담는다. 그리고 최종적으로 0이 남아있는 배열에서 splice(1)으로 배열에서 0을 제외한다.

---
